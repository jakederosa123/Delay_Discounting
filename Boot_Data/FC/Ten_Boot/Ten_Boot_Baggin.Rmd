---
title: "Bagging Pipeline: CBCL"
author: "Jacob DeRosa"
output:
  html_document:
    number_sections: no
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
      
---

```{r, echo = F, include = F}


#load Libraries 
library(knitr)
library(dplyr)
library(purrr)
library(reshape2)
library(tidyr)
library(stringi)
library(ggplot2)
library(ggiraphExtra)
library(gplots)
library(RColorBrewer)
library(viridis)
library(viridis)
library(corrplot)
library(igraph)
library(psych)   

#increase to max memory limit if using windows -- hash out for mac 
memory.limit(10000000000000) 

```

```{r, warning = F, echo=F, include=F}

### This script must be saved in the same folder as the bootstrapped cluster output CSVs in order for the data to read in 

# read in data from cluster output into a list
#setwd("C:/Users/jacob.derosa/Desktop/Scripts/Baggin_Subtyping/CBCL/Boot_Data")
setwd("~/GitHub/Delay_Discounting/Boot_Data/FC/Ten_Boot")
```

```{r, warning = F, echo=F, include=F}

my_data = lapply(list.files(pattern = glob2rx("*.csv")), read.csv, header = T, sep = ",") 

python_df = read.csv("C:/Users/jacob.derosa/Documents/Github/Delay_Discounting/Data/Ten_Twelve.csv", header = T, sep = ",") %>% rename(Key = X) #make sure subject Key is the first column of your dataframe
python_list = list(python_df[1])#put python df into list that will merged with sample split dfs and select only subject KEY 
df_list = Map(full_join, my_data, python_list, by = c("Key")) #Combine clustered data with data frame that contains CBCL scores and subject ID 

#initialize empty lists
boot = list() #contains data frame of cluster outputs and subject IDS. 
boot_NA = list() #list of subjects that were not included in the bootsrapped data and contain NA's, used to generate a list of subjects that will be removed from the adjacency matrix
list = list() #list of subjects to be removed from the adjacency matrix
adj = list() #list of adjacency matrices 
boot_mask = list() #contains data frame of cluster outputs and subject IDS. 
boot_NA_mask = list() #list of subjects that were not included in the bootsrapped data and contain NA's, used to generate a list of subjects that will be removed from the adjacency matrix
mask_list = list() #list of subjects to be removed from the adjacency matrix
mask = list() ##list of adjacency matrices 

for(i in 1:length(df_list)){
  boot[[i]] = df_list[[i]]
  boot[[i]] = df_list[[i]][!duplicated(df_list[[i]]$Key),]#remove duplicate subject IDs from bootstrapped data. If no duplicate data is present no subjects will be removed (ex: non bootstrapped data set)
  boot[[i]]$cluster = boot[[i]]$cluster %>% replace_na(0)#Give all subjects a 0 as a cluster label of 0 that did not go into the dataset 
  boot_NA[[i]] = boot[[i]] %>% filter(cluster == 0) #create a list of all subject IDs that have a cluster label of 0 (important for when their row and column are removed from the adjacency matrix)
  list[[i]] = boot_NA[[i]]$Key #assign subjects wuth a 0 to this list 
  adj[[i]] <- +(outer(boot[[i]]$cluster, boot[[i]]$cluster, FUN='=='))*!diag(dim(boot[[i]])[1]) #create the adjacency matrix with 1 and 0: 1 for subjects that have the same cluster assignment as another subject and 0 for subjects that do not have the same cluster assignment. 
  diag(adj[[i]]) <- 0 #set the diagonal of the adjacency matrix to 0
  dimnames(adj[[i]]) <- rep(list(boot[[i]]$Key),2) #Add subject ID to the matrix as column and row headers 
  adj[[i]] = adj[[i]][!rownames(adj[[i]]) %in% list[[i]], !colnames(adj[[i]]) %in% list[[i]]] #remove subjects who had a cluster of 0 with form the previously generated list. 
  ## Create Masks 
  boot_mask[[i]] = df_list[[i]]
  boot_mask[[i]] = df_list[[i]][!duplicated(df_list[[i]]$Key),]#remove duplicate subject IDs from bootstrapped data. If no duplicate data is present no subjects will be removed (ex: non bootstrapped data set)
  boot_mask[[i]]$cluster = boot_mask[[i]]$cluster %>% replace_na(0)
  boot_mask[[i]] = boot_mask[[i]] %>% mutate(cluster = ifelse(cluster == 0, 0, 1)) #create mask matrix, 1 if included in the boostrapped iteration, 0 if not included. 
  #Give all subjects a 0 as a cluster label of 0 that did not go into the dataset 
  boot_NA_mask[[i]] = boot_mask[[i]] %>% filter(cluster == 0) #create a list of all subject IDs that have a cluster label of 0 (important for when their row and column are removed from the adjacency matrix)
  mask_list[[i]] = boot_NA_mask[[i]]$Key #assign subjects wuth a 0 to this list 
  mask[[i]] <- +(outer(boot_mask[[i]]$cluster, boot_mask[[i]]$cluster, FUN='=='))*!diag(dim(boot_mask[[i]])[1]) #create the adjacency matrix with 1 and 0: 1 for subjects that have the same cluster assignment as another subject and 0 for subjects that do not have the same cluster assignment. 
  diag(mask[[i]]) <- 0 #set the diagonal of the adjacency matrix to 0
  dimnames(mask[[i]]) <- rep(list(boot_mask[[i]]$Key),2) #Add subject ID to the matrix as column and row headers 
  mask[[i]] = mask[[i]][!rownames(mask[[i]]) %in% mask_list[[i]], !colnames(mask[[i]]) %in% mask_list[[i]]] 
}


adj_full_1 = acast(rbind(melt(adj[1:100])), Var1~Var2, sum)
mask_full_1 = acast(rbind(melt(mask[1:100])), Var1~Var2, sum)
stab_full_split_1 = adj_full_1/mask_full_1 
diag(stab_full_split_1) = 0
```


```{r, include=F, echo = F}

#obtain Key (subject identifier) from the stability matrices and place them into a new data frame 
subs = data.frame("Key" = as.factor(colnames(stab_full_split_1)))# Split 1 

```

# Louvain Final Clustering Solutions
```{r, echo =F, include=F}

G1 <- graph.adjacency(stab_full_split_1, mode = "undirected", weighted = TRUE, diag = TRUE) #turn final stability matrix into a graph, Weighted NEEDS = TRUE, if not there will be over 100 cluster assignments!!!
clusterlouvain <- cluster_louvain(G1) 
subs$cluster = factor(clusterlouvain$membership) 

python_df$Key = factor(python_df$Key)
Split_1 = subs %>% inner_join(python_df, by = c("Key")) 
```

# ***Heatmaps***

```{r, echo = F}

gr.row <- subs$cluster # cluster assignments
col1 <- brewer.pal(6, "Set1")

heatmap.2(stab_full_split_1,
          #Rowv=as.dendrogram(hyb1),
          #Colv=as.dendrogram(hyb1),
          RowSideColors=col1[gr.row],
          col=viridis_pal(),
          labRow = F,
          labCol = F,
          main = "Split 1 Heatmap",
          trace = "none")

```

# Split 1
```{r, echo = F, fig.height= 10, fig.width=15}

data <- Split_1 %>% select(cluster, X.3..8., X.3..9., X.7..13., X.1..12., X.1..6., X.10..0., X.3..12., X.7..12., X.4..11.) %>%
  group_by(cluster) %>% 
  summarise(
  Left.dlPFC_Right.dACC = mean(X.3..8.), 
   Left.dlPFC_Right.dlPFC = mean(X.3..9.), 
  Left.Superior.FC_Right.Superior.FC = mean(X.7..13.),
  Right.Pallidum_Right.PCC = mean(X.1..12.),
  Right.Pallidum_Left.PCC = mean(X.1..6.),
  Right.mOFC_Left.Amygdala = mean(X.10..0.),
  Left.dlPFC_Right.PCC = mean(X.3..12.),
  Left.Superior.FC_Right.PCC = mean(X.7..12.),
  Left.mOFC_Right.vlPFC = mean(X.4..11.))


colors_line = c(scales::alpha("#440154FF", 1),
                scales::alpha("#3B528BFF", 1),
                scales::alpha("#73D055FF", 1),
                scales::alpha("#FDE725FF", 1))

data = gather(data, "Var", "Mean",Left.dlPFC_Right.dACC:Left.mOFC_Right.vlPFC, factor_key = F) %>% rename(Subtype = cluster)
data$Subtype = factor(data$Subtype)
#Turn your 'treatment' column into a character vector
data$Var <- as.character(data$Var)
#Then turn it back into a factor with the levels in the correct order
data$Var <- factor(data$Var, levels=unique(data$Var))

ggplot(data, aes(x=factor(Var), y=Mean, group=Subtype)) +
  geom_line(aes(color = Subtype), size = 5) +
   labs(x="", y="") +
  ggtitle("") +
  #scale_colour_manual(values=colors_line) +
  scale_colour_manual(values=col1) +
  theme(axis.line = element_line(size=2, colour = "black"),
        panel.grid.major = element_line(colour = "#d3d3d3"), panel.grid.minor = element_blank(),
        panel.border = element_blank(), panel.background = element_blank()) +
  theme(plot.title = element_text(size = 14, face = "bold"),
        axis.text.x=element_text(colour="black", size = 10),
        axis.text.y=element_text(colour="black", size = 10),
        legend.key=element_rect(fill="white", colour="white")) + 
    theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1, size= 23, face = "bold")) +
  theme(
    panel.grid.major = element_line(colour = "black", linetype = "dotted", size = 1.5),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(), 
          axis.text.y = element_text(face="bold", color="black", 
                           size=20),
    axis.ticks.length=unit(0.3,"cm"),
    axis.ticks.x=element_line(size=2),
    axis.ticks.y=element_line(size=2)) + 
  theme(
    legend.title = element_text(size = 30), 
    legend.text = element_text(size = 30))  


```

```{r}

Split_1$cluster = as.factor(Split_1$cluster)
Split_1$Sex = as.factor(Split_1$Sex)

summary(aov(FA3 ~ cluster*Sex, data = Split_1))

```
